///
/// RNNitroSQLite-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `ArrayBufferHolder` to properly resolve imports.
namespace NitroModules { class ArrayBufferHolder; }
// Forward declaration of `ArrayBuffer` to properly resolve imports.
namespace NitroModules { class ArrayBuffer; }
// Forward declaration of `BatchQueryCommand` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { struct BatchQueryCommand; }
// Forward declaration of `BatchQueryResult` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { struct BatchQueryResult; }
// Forward declaration of `ColumnType` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { enum class ColumnType; }
// Forward declaration of `FileLoadResult` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { struct FileLoadResult; }
// Forward declaration of `HybridNativeQueryResultSpecSwift` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { class HybridNativeQueryResultSpecSwift; }
// Forward declaration of `HybridNativeQueryResultSpec` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { class HybridNativeQueryResultSpec; }
// Forward declaration of `SQLiteQueryColumnMetadata` to properly resolve imports.
namespace margelo::nitro::rnnitrosqlite { struct SQLiteQueryColumnMetadata; }

// Include C++ defined types
#if __has_include("BatchQueryCommand.hpp")
 #include "BatchQueryCommand.hpp"
#endif
#if __has_include("BatchQueryResult.hpp")
 #include "BatchQueryResult.hpp"
#endif
#if __has_include("ColumnType.hpp")
 #include "ColumnType.hpp"
#endif
#if __has_include("FileLoadResult.hpp")
 #include "FileLoadResult.hpp"
#endif
#if __has_include("HybridNativeQueryResultSpec.hpp")
 #include "HybridNativeQueryResultSpec.hpp"
#endif
#if __has_include("HybridNativeQueryResultSpecSwift.hpp")
 #include "HybridNativeQueryResultSpecSwift.hpp"
#endif
#if __has_include("SQLiteQueryColumnMetadata.hpp")
 #include "SQLiteQueryColumnMetadata.hpp"
#endif
#if __has_include(<NitroModules/ArrayBuffer.hpp>)
 #include <NitroModules/ArrayBuffer.hpp>
#endif
#if __has_include(<NitroModules/ArrayBufferHolder.hpp>)
 #include <NitroModules/ArrayBufferHolder.hpp>
#endif
#if __has_include(<NitroModules/PromiseHolder.hpp>)
 #include <NitroModules/PromiseHolder.hpp>
#endif
#if __has_include(<future>)
 #include <future>
#endif
#if __has_include(<memory>)
 #include <memory>
#endif
#if __has_include(<optional>)
 #include <optional>
#endif
#if __has_include(<string>)
 #include <string>
#endif
#if __has_include(<unordered_map>)
 #include <unordered_map>
#endif
#if __has_include(<variant>)
 #include <variant>
#endif
#if __has_include(<vector>)
 #include <vector>
#endif

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::rnnitrosqlite::bridge::swift {

  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) {
    return std::optional<double>(value);
  }
  
  /**
   * Wrapper struct for `std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ {
    std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> variant;
    std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>> variant): variant(variant) { }
    operator std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>() const {
      return variant;
    }
    inline size_t index() const {
      return variant.index();
    }
  };
  inline std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const std::string& value) {
    return std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(value);
  }
  inline std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(double value) {
    return std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(value);
  }
  inline std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(int64_t value) {
    return std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(value);
  }
  inline std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(bool value) {
    return std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(value);
  }
  inline std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__ create_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(const std::shared_ptr<ArrayBuffer>& value) {
    return std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__(value);
  }
  inline std::string get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___0(const std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& variantWrapper) {
    return std::get<0>(variantWrapper.variant);
  }
  inline double get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___1(const std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& variantWrapper) {
    return std::get<1>(variantWrapper.variant);
  }
  inline int64_t get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___2(const std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& variantWrapper) {
    return std::get<2>(variantWrapper.variant);
  }
  inline bool get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___3(const std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& variantWrapper) {
    return std::get<3>(variantWrapper.variant);
  }
  inline std::shared_ptr<ArrayBuffer> get_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___4(const std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer__& variantWrapper) {
    return std::get<4>(variantWrapper.variant);
  }
  
  /**
   * Specialized version of `std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>`.
   */
  using std__unordered_map_std__string__std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ = std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>;
  inline std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> create_std__unordered_map_std__string__std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(size_t size) {
    std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____keys(const std__unordered_map_std__string__std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___& map) {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  
  /**
   * Specialized version of `std::vector<std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>`.
   */
  using std__vector_std__unordered_map_std__string__std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____ = std::vector<std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>;
  inline std::vector<std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> create_std__vector_std__unordered_map_std__string__std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____(size_t size) {
    std::vector<std::unordered_map<std::string, std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::unordered_map<std::string, SQLiteQueryColumnMetadata>`.
   */
  using std__unordered_map_std__string__SQLiteQueryColumnMetadata_ = std::unordered_map<std::string, SQLiteQueryColumnMetadata>;
  inline std::unordered_map<std::string, SQLiteQueryColumnMetadata> create_std__unordered_map_std__string__SQLiteQueryColumnMetadata_(size_t size) {
    std::unordered_map<std::string, SQLiteQueryColumnMetadata> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__SQLiteQueryColumnMetadata__keys(const std__unordered_map_std__string__SQLiteQueryColumnMetadata_& map) {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  
  /**
   * Specialized version of `std::optional<std::unordered_map<std::string, SQLiteQueryColumnMetadata>>`.
   */
  using std__optional_std__unordered_map_std__string__SQLiteQueryColumnMetadata__ = std::optional<std::unordered_map<std::string, SQLiteQueryColumnMetadata>>;
  inline std::optional<std::unordered_map<std::string, SQLiteQueryColumnMetadata>> create_std__optional_std__unordered_map_std__string__SQLiteQueryColumnMetadata__(const std::unordered_map<std::string, SQLiteQueryColumnMetadata>& value) {
    return std::optional<std::unordered_map<std::string, SQLiteQueryColumnMetadata>>(value);
  }
  
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) {
    return std::optional<std::string>(value);
  }
  
  /**
   * Specialized version of `std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>`.
   */
  using std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___ = std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>;
  inline std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> create_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer___(size_t size) {
    std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>`.
   */
  using std__optional_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____ = std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>;
  inline std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> create_std__optional_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____(const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& value) {
    return std::optional<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::shared_ptr<margelo::nitro::rnnitrosqlite::HybridNativeQueryResultSpec>>`.
   */
  using PromiseHolder_std__shared_ptr_margelo__nitro__rnnitrosqlite__HybridNativeQueryResultSpec__ = PromiseHolder<std::shared_ptr<margelo::nitro::rnnitrosqlite::HybridNativeQueryResultSpec>>;
  inline PromiseHolder<std::shared_ptr<margelo::nitro::rnnitrosqlite::HybridNativeQueryResultSpec>> create_PromiseHolder_std__shared_ptr_margelo__nitro__rnnitrosqlite__HybridNativeQueryResultSpec__() {
    return PromiseHolder<std::shared_ptr<margelo::nitro::rnnitrosqlite::HybridNativeQueryResultSpec>>();
  }
  
  /**
   * Specialized version of `std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>`.
   */
  using std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____ = std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>;
  inline std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> create_std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer____(size_t size) {
    std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Wrapper struct for `std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____ {
    std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>> variant;
    std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>> variant): variant(variant) { }
    operator std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>() const {
      return variant;
    }
    inline size_t index() const {
      return variant.index();
    }
  };
  inline std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____ create_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(const std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>& value) {
    return std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(value);
  }
  inline std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____ create_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(const std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>& value) {
    return std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____(value);
  }
  inline std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>> get_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______0(const std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____& variantWrapper) {
    return std::get<0>(variantWrapper.variant);
  }
  inline std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>> get_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______1(const std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____& variantWrapper) {
    return std::get<1>(variantWrapper.variant);
  }
  
  /**
   * Specialized version of `std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>>`.
   */
  using std__optional_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______ = std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>>;
  inline std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>> create_std__optional_std__variant_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer_____std__vector_std__vector_std__variant_std__string__double__int64_t__bool__std__shared_ptr_ArrayBuffer______(const std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>& value) {
    return std::optional<std::variant<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>, std::vector<std::vector<std::variant<std::string, double, int64_t, bool, std::shared_ptr<ArrayBuffer>>>>>>(value);
  }
  
  /**
   * Specialized version of `std::vector<BatchQueryCommand>`.
   */
  using std__vector_BatchQueryCommand_ = std::vector<BatchQueryCommand>;
  inline std::vector<BatchQueryCommand> create_std__vector_BatchQueryCommand_(size_t size) {
    std::vector<BatchQueryCommand> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `PromiseHolder<BatchQueryResult>`.
   */
  using PromiseHolder_BatchQueryResult_ = PromiseHolder<BatchQueryResult>;
  inline PromiseHolder<BatchQueryResult> create_PromiseHolder_BatchQueryResult_() {
    return PromiseHolder<BatchQueryResult>();
  }
  
  /**
   * Specialized version of `PromiseHolder<FileLoadResult>`.
   */
  using PromiseHolder_FileLoadResult_ = PromiseHolder<FileLoadResult>;
  inline PromiseHolder<FileLoadResult> create_PromiseHolder_FileLoadResult_() {
    return PromiseHolder<FileLoadResult>();
  }

} // namespace margelo::nitro::rnnitrosqlite::bridge::swift
